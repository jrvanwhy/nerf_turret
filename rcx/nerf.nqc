// Tuning values
#define LIGHT_THRESH 63
#define HOLD_PWR      1
#define PULL_TIME     5
#define LIGHT_TOUT    2
#define SMPL_PERIOD  10

// Indices
#define LIGHT_IN   SENSOR_1
#define ACC_MOTOR  OUT_A
#define TRIG_MOTOR OUT_C
#define SMPL_TIMER 0

// State machine states enumeration
#define STATE_IDLE     0
#define STATE_ACCPULL  1
#define STATE_ACCHOLD  2
#define STATE_TRIGPULL 3
#define STATE_FIRING   4

// Global state information, required
// by every state in the state machine
int state     = STATE_IDLE; // Current state machine state
int isLightOn = false;      // Whether the NXT's light is on
int holdCntr  = 0;          // For checking if light is flashing
int stateCntr = 0;          // Number of iterations in this state.

// Macro for checking if the light is being held
#define IS_LIGHT_HOLD (holdCntr >= LIGHT_TOUT)

// Idle state -- waiting to begin firing
void state_idle() {
	if (isLightOn) {
		SetPower(ACC_MOTOR, OUT_FULL);
		On(ACC_MOTOR);
		state     = STATE_ACCPULL;
		stateCntr = 0;
	}
}

// Currently pulling the accelerator
void state_accpull() {
	// Update the state timer
	++stateCntr;

	// Check if the light's turned off.
	// If so, shut off the accelerator winch and
	// go back to STATE_IDLE
	if (!isLightOn) {
		if (IS_LIGHT_HOLD) {
			Float(ACC_MOTOR);
			state = STATE_IDLE;
			return;
		}
	}

	// Check if the pull's complete. If so, switch to
	// STATE_ACCHOLD
	if (stateCntr >= PULL_TIME) {
		SetPower(ACC_MOTOR, HOLD_PWR);
		state = STATE_ACCHOLD;
	}
}

// Holding the accelerator... "intimidate" mode.
void state_acchold() {
	// Don't do anything if the light isn't solid.
	// (i.e. if it's flashing, stay in this mode.
	if (!IS_LIGHT_HOLD) {
		return;
	}

	// Since the light's being held, check its value to determine
	// if we're going back to STATE_IDLE or continuing to
	// STATE_TRIGPULL
	if (isLightOn) {
		// Go to STATE_TRIGPULL
		SetPower(TRIG_MOTOR, OUT_FULL);
		On(TRIG_MOTOR);
		state = STATE_TRIGPULL;
		stateCntr = 0;
	} else {
		// Go to STATE_IDLE
		Float(ACC_MOTOR);
		state = STATE_IDLE;
	}
}

// Pulling the trigger
void state_trigpull() {
	// Update the state counter
	++stateCntr;

	// Check if the light's turned off -- if so, go back to intimidate
	if (!isLightOn) {
		Float(TRIG_MOTOR);
		state = STATE_ACCHOLD;
		return;
	}

	// Light's still on... if the timer's expired,
	// go to STATE_FIRING
	if (stateCntr >= PULL_TIME) {
		SetPower(TRIG_MOTOR, HOLD_PWR);
		state = STATE_FIRING;
	}
}

// Currently firing
void state_firing() {
	// Check if the light's turned off -- if so, go right back to
	// intimidate mode.
	if (!isLightOn) {
		Float(TRIG_MOTOR);
		state = STATE_ACCHOLD;
		return;
	}
}

task main()
{
	// Initialization
	SetSensor(LIGHT_IN, SENSOR_LIGHT);

	// Reset the timer or it exits immediately
	ClearTimer(SMPL_TIMER);

	// Main loop
	while (true) {
		// Debugging: Performance check. TODO: Remove
		if (FastTimer(SMPL_TIMER) >= SMPL_PERIOD) {
			break;
		}

		// Wait until it's time to sample again, then reset the timer and sample
		while (FastTimer(SMPL_TIMER) < SMPL_PERIOD);
		ClearTimer(SMPL_TIMER);
		int newIsLightOn = (LIGHT_IN > LIGHT_THRESH);

		// Check if the light just changed or if it's holding
		// its previous value.
		if (isLightOn == newIsLightOn) {
			++holdCntr;
		} else {
			isLightOn = newIsLightOn;
			holdCntr  = 0;
		}

		// Run the function for the current state
		switch (state) {
			case STATE_IDLE:
				state_idle();
				break;

			case STATE_ACCPULL:
				state_accpull();
				break;

			case STATE_ACCHOLD:
				state_acchold();
				break;

			case STATE_TRIGPULL:
				state_trigpull();
				break;

			case STATE_FIRING:
				state_firing();
				break;
		}
	}
}
